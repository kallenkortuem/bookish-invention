/* tslint:disable */
/* eslint-disable */
/**
 * Riot API
 *  OpenAPI/Swagger version of the [Riot API](https://developer.riotgames.com/). Automatically generated daily. ## OpenAPI Spec File The following versions of the Riot API spec file are available: - `openapi-3.0.0.json` ([view file](../openapi-3.0.0.json), [ui select](?url=../openapi-3.0.0.json)) - `openapi-3.0.0.min.json` ([view file](../openapi-3.0.0.min.json), [ui select](?url=../openapi-3.0.0.min.json)) - `openapi-3.0.0.yml` ([view file](../openapi-3.0.0.yml), [ui select](?url=../openapi-3.0.0.yml)) - `openapi-3.0.0.min.yml` ([view file](../openapi-3.0.0.min.yml), [ui select](?url=../openapi-3.0.0.min.yml)) - `swaggerspec-2.0.json` ([view file](../swaggerspec-2.0.json), [ui select](?url=../swaggerspec-2.0.json)) - `swaggerspec-2.0.min.json` ([view file](../swaggerspec-2.0.min.json), [ui select](?url=../swaggerspec-2.0.min.json)) - `swaggerspec-2.0.yml` ([view file](../swaggerspec-2.0.yml), [ui select](?url=../swaggerspec-2.0.yml)) - `swaggerspec-2.0.min.yml` ([view file](../swaggerspec-2.0.min.yml), [ui select](?url=../swaggerspec-2.0.min.yml)) ## Other Files - Missing DTOs: [`missing.json`](../missing.json) - [Enum Files](../enums/) ## Source Code Source code on [GitHub](https://github.com/MingweiSamuel/riotapi-schema). Pull requests welcome! ## Automatically Generated Rebuilt on [Travis CI](https://travis-ci.com/MingweiSamuel/riotapi-schema/builds) daily. *** 
 *
 * The version of the OpenAPI document: f14f3a4b603d31d9d2090720bd518853c6a65bbb
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from '../common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
// @ts-ignore
import { MatchV4MatchDto } from '../model';
// @ts-ignore
import { MatchV4MatchTimelineDto } from '../model';
// @ts-ignore
import { MatchV4MatchlistDto } from '../model';
/**
 * MatchV4Api - axios parameter creator
 * @export
 */
export const MatchV4ApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get match by match ID.
         * @summary Get match by match ID.
         * @param {number} matchId The match ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        matchV4GetMatch: async (matchId: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'matchId' is not null or undefined
            assertParamExists('matchV4GetMatch', 'matchId', matchId)
            const localVarPath = `/lol/match/v4/matches/{matchId}`
                .replace(`{${"matchId"}}`, encodeURIComponent(String(matchId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Riot-Token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Riot-Token", configuration)

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get match by match ID and tournament code.
         * @summary Get match by match ID and tournament code.
         * @param {string} tournamentCode The tournament code.
         * @param {number} matchId The match ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        matchV4GetMatchByTournamentCode: async (tournamentCode: string, matchId: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'tournamentCode' is not null or undefined
            assertParamExists('matchV4GetMatchByTournamentCode', 'tournamentCode', tournamentCode)
            // verify required parameter 'matchId' is not null or undefined
            assertParamExists('matchV4GetMatchByTournamentCode', 'matchId', matchId)
            const localVarPath = `/lol/match/v4/matches/{matchId}/by-tournament-code/{tournamentCode}`
                .replace(`{${"tournamentCode"}}`, encodeURIComponent(String(tournamentCode)))
                .replace(`{${"matchId"}}`, encodeURIComponent(String(matchId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Riot-Token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Riot-Token", configuration)

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get match IDs by tournament code.
         * @summary Get match IDs by tournament code.
         * @param {string} tournamentCode The tournament code.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        matchV4GetMatchIdsByTournamentCode: async (tournamentCode: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'tournamentCode' is not null or undefined
            assertParamExists('matchV4GetMatchIdsByTournamentCode', 'tournamentCode', tournamentCode)
            const localVarPath = `/lol/match/v4/matches/by-tournament-code/{tournamentCode}/ids`
                .replace(`{${"tournamentCode"}}`, encodeURIComponent(String(tournamentCode)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Riot-Token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Riot-Token", configuration)

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get match timeline by match ID. ## Implementation Notes Not all matches have timeline data.
         * @summary Get match timeline by match ID.
         * @param {number} matchId The match ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        matchV4GetMatchTimeline: async (matchId: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'matchId' is not null or undefined
            assertParamExists('matchV4GetMatchTimeline', 'matchId', matchId)
            const localVarPath = `/lol/match/v4/timelines/by-match/{matchId}`
                .replace(`{${"matchId"}}`, encodeURIComponent(String(matchId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Riot-Token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Riot-Token", configuration)

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get matchlist for games played on given account ID and platform ID and filtered using given filter parameters, if any. ## Implementation Notes A number of optional parameters are provided for filtering. It is up to the caller to ensure that the combination of filter parameters provided is valid for the requested account, otherwise, no matches may be returned.  If beginIndex is specified, but not endIndex, then endIndex defaults to beginIndex+100. If endIndex is specified, but not beginIndex, then beginIndex defaults to 0. If both are specified, then endIndex must be greater than beginIndex. The maximum range allowed is 100, otherwise a 400 error code is returned.  If beginTime is specified, but not endTime, then endTime defaults to the the current unix timestamp in milliseconds (the maximum time range limitation is not observed in this specific case). If endTime is specified, but not beginTime, then beginTime defaults to the start of the account\'s match history returning a 400 due to the maximum time range limitation. If both are specified, then endTime should be greater than beginTime. The maximum time range allowed is one week, otherwise a 400 error code is returned.
         * @summary Get matchlist for games played on given account ID and platform ID and filtered using given filter parameters, if any.
         * @param {string} encryptedAccountId The account ID.
         * @param {Array<number>} [champion] Set of champion IDs for filtering the matchlist.
         * @param {Array<number>} [queue] Set of queue IDs for filtering the matchlist.
         * @param {Array<number>} [season] [DEPRECATED] This field should not be considered reliable for the purposes of filtering matches by season.
         * @param {number} [endTime] The end time to use for filtering matchlist specified as epoch milliseconds. If beginTime is specified, but not endTime, then endTime defaults to the the current unix timestamp in milliseconds (the maximum time range limitation is not observed in this specific case). If endTime is specified, but not beginTime, then beginTime defaults to the start of the account\&#39;s match history returning a 400 due to the maximum time range limitation. If both are specified, then endTime should be greater than beginTime. The maximum time range allowed is one week, otherwise a 400 error code is returned.
         * @param {number} [beginTime] The begin time to use for filtering matchlist specified as epoch milliseconds. If beginTime is specified, but not endTime, then endTime defaults to the the current unix timestamp in milliseconds (the maximum time range limitation is not observed in this specific case). If endTime is specified, but not beginTime, then beginTime defaults to the start of the account\&#39;s match history returning a 400 due to the maximum time range limitation. If both are specified, then endTime should be greater than beginTime. The maximum time range allowed is one week, otherwise a 400 error code is returned.
         * @param {number} [endIndex] The end index to use for filtering matchlist. If beginIndex is specified, but not endIndex, then endIndex defaults to beginIndex+100. If endIndex is specified, but not beginIndex, then beginIndex defaults to 0. If both are specified, then endIndex must be greater than beginIndex. The maximum range allowed is 100, otherwise a 400 error code is returned.
         * @param {number} [beginIndex] The begin index to use for filtering matchlist.  If beginIndex is specified, but not endIndex, then endIndex defaults to beginIndex+100. If endIndex is specified, but not beginIndex, then beginIndex defaults to 0. If both are specified, then endIndex must be greater than beginIndex. The maximum range allowed is 100, otherwise a 400 error code is returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        matchV4GetMatchlist: async (encryptedAccountId: string, champion?: Array<number>, queue?: Array<number>, season?: Array<number>, endTime?: number, beginTime?: number, endIndex?: number, beginIndex?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'encryptedAccountId' is not null or undefined
            assertParamExists('matchV4GetMatchlist', 'encryptedAccountId', encryptedAccountId)
            const localVarPath = `/lol/match/v4/matchlists/by-account/{encryptedAccountId}`
                .replace(`{${"encryptedAccountId"}}`, encodeURIComponent(String(encryptedAccountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Riot-Token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Riot-Token", configuration)

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_key", configuration)

            if (champion) {
                localVarQueryParameter['champion'] = champion;
            }

            if (queue) {
                localVarQueryParameter['queue'] = queue;
            }

            if (season) {
                localVarQueryParameter['season'] = season;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = endTime;
            }

            if (beginTime !== undefined) {
                localVarQueryParameter['beginTime'] = beginTime;
            }

            if (endIndex !== undefined) {
                localVarQueryParameter['endIndex'] = endIndex;
            }

            if (beginIndex !== undefined) {
                localVarQueryParameter['beginIndex'] = beginIndex;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MatchV4Api - functional programming interface
 * @export
 */
export const MatchV4ApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MatchV4ApiAxiosParamCreator(configuration)
    return {
        /**
         * Get match by match ID.
         * @summary Get match by match ID.
         * @param {number} matchId The match ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async matchV4GetMatch(matchId: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MatchV4MatchDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.matchV4GetMatch(matchId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get match by match ID and tournament code.
         * @summary Get match by match ID and tournament code.
         * @param {string} tournamentCode The tournament code.
         * @param {number} matchId The match ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async matchV4GetMatchByTournamentCode(tournamentCode: string, matchId: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MatchV4MatchDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.matchV4GetMatchByTournamentCode(tournamentCode, matchId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get match IDs by tournament code.
         * @summary Get match IDs by tournament code.
         * @param {string} tournamentCode The tournament code.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async matchV4GetMatchIdsByTournamentCode(tournamentCode: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<number>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.matchV4GetMatchIdsByTournamentCode(tournamentCode, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get match timeline by match ID. ## Implementation Notes Not all matches have timeline data.
         * @summary Get match timeline by match ID.
         * @param {number} matchId The match ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async matchV4GetMatchTimeline(matchId: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MatchV4MatchTimelineDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.matchV4GetMatchTimeline(matchId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get matchlist for games played on given account ID and platform ID and filtered using given filter parameters, if any. ## Implementation Notes A number of optional parameters are provided for filtering. It is up to the caller to ensure that the combination of filter parameters provided is valid for the requested account, otherwise, no matches may be returned.  If beginIndex is specified, but not endIndex, then endIndex defaults to beginIndex+100. If endIndex is specified, but not beginIndex, then beginIndex defaults to 0. If both are specified, then endIndex must be greater than beginIndex. The maximum range allowed is 100, otherwise a 400 error code is returned.  If beginTime is specified, but not endTime, then endTime defaults to the the current unix timestamp in milliseconds (the maximum time range limitation is not observed in this specific case). If endTime is specified, but not beginTime, then beginTime defaults to the start of the account\'s match history returning a 400 due to the maximum time range limitation. If both are specified, then endTime should be greater than beginTime. The maximum time range allowed is one week, otherwise a 400 error code is returned.
         * @summary Get matchlist for games played on given account ID and platform ID and filtered using given filter parameters, if any.
         * @param {string} encryptedAccountId The account ID.
         * @param {Array<number>} [champion] Set of champion IDs for filtering the matchlist.
         * @param {Array<number>} [queue] Set of queue IDs for filtering the matchlist.
         * @param {Array<number>} [season] [DEPRECATED] This field should not be considered reliable for the purposes of filtering matches by season.
         * @param {number} [endTime] The end time to use for filtering matchlist specified as epoch milliseconds. If beginTime is specified, but not endTime, then endTime defaults to the the current unix timestamp in milliseconds (the maximum time range limitation is not observed in this specific case). If endTime is specified, but not beginTime, then beginTime defaults to the start of the account\&#39;s match history returning a 400 due to the maximum time range limitation. If both are specified, then endTime should be greater than beginTime. The maximum time range allowed is one week, otherwise a 400 error code is returned.
         * @param {number} [beginTime] The begin time to use for filtering matchlist specified as epoch milliseconds. If beginTime is specified, but not endTime, then endTime defaults to the the current unix timestamp in milliseconds (the maximum time range limitation is not observed in this specific case). If endTime is specified, but not beginTime, then beginTime defaults to the start of the account\&#39;s match history returning a 400 due to the maximum time range limitation. If both are specified, then endTime should be greater than beginTime. The maximum time range allowed is one week, otherwise a 400 error code is returned.
         * @param {number} [endIndex] The end index to use for filtering matchlist. If beginIndex is specified, but not endIndex, then endIndex defaults to beginIndex+100. If endIndex is specified, but not beginIndex, then beginIndex defaults to 0. If both are specified, then endIndex must be greater than beginIndex. The maximum range allowed is 100, otherwise a 400 error code is returned.
         * @param {number} [beginIndex] The begin index to use for filtering matchlist.  If beginIndex is specified, but not endIndex, then endIndex defaults to beginIndex+100. If endIndex is specified, but not beginIndex, then beginIndex defaults to 0. If both are specified, then endIndex must be greater than beginIndex. The maximum range allowed is 100, otherwise a 400 error code is returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async matchV4GetMatchlist(encryptedAccountId: string, champion?: Array<number>, queue?: Array<number>, season?: Array<number>, endTime?: number, beginTime?: number, endIndex?: number, beginIndex?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MatchV4MatchlistDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.matchV4GetMatchlist(encryptedAccountId, champion, queue, season, endTime, beginTime, endIndex, beginIndex, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * MatchV4Api - factory interface
 * @export
 */
export const MatchV4ApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MatchV4ApiFp(configuration)
    return {
        /**
         * Get match by match ID.
         * @summary Get match by match ID.
         * @param {number} matchId The match ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        matchV4GetMatch(matchId: number, options?: any): AxiosPromise<MatchV4MatchDto> {
            return localVarFp.matchV4GetMatch(matchId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get match by match ID and tournament code.
         * @summary Get match by match ID and tournament code.
         * @param {string} tournamentCode The tournament code.
         * @param {number} matchId The match ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        matchV4GetMatchByTournamentCode(tournamentCode: string, matchId: number, options?: any): AxiosPromise<MatchV4MatchDto> {
            return localVarFp.matchV4GetMatchByTournamentCode(tournamentCode, matchId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get match IDs by tournament code.
         * @summary Get match IDs by tournament code.
         * @param {string} tournamentCode The tournament code.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        matchV4GetMatchIdsByTournamentCode(tournamentCode: string, options?: any): AxiosPromise<Array<number>> {
            return localVarFp.matchV4GetMatchIdsByTournamentCode(tournamentCode, options).then((request) => request(axios, basePath));
        },
        /**
         * Get match timeline by match ID. ## Implementation Notes Not all matches have timeline data.
         * @summary Get match timeline by match ID.
         * @param {number} matchId The match ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        matchV4GetMatchTimeline(matchId: number, options?: any): AxiosPromise<MatchV4MatchTimelineDto> {
            return localVarFp.matchV4GetMatchTimeline(matchId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get matchlist for games played on given account ID and platform ID and filtered using given filter parameters, if any. ## Implementation Notes A number of optional parameters are provided for filtering. It is up to the caller to ensure that the combination of filter parameters provided is valid for the requested account, otherwise, no matches may be returned.  If beginIndex is specified, but not endIndex, then endIndex defaults to beginIndex+100. If endIndex is specified, but not beginIndex, then beginIndex defaults to 0. If both are specified, then endIndex must be greater than beginIndex. The maximum range allowed is 100, otherwise a 400 error code is returned.  If beginTime is specified, but not endTime, then endTime defaults to the the current unix timestamp in milliseconds (the maximum time range limitation is not observed in this specific case). If endTime is specified, but not beginTime, then beginTime defaults to the start of the account\'s match history returning a 400 due to the maximum time range limitation. If both are specified, then endTime should be greater than beginTime. The maximum time range allowed is one week, otherwise a 400 error code is returned.
         * @summary Get matchlist for games played on given account ID and platform ID and filtered using given filter parameters, if any.
         * @param {string} encryptedAccountId The account ID.
         * @param {Array<number>} [champion] Set of champion IDs for filtering the matchlist.
         * @param {Array<number>} [queue] Set of queue IDs for filtering the matchlist.
         * @param {Array<number>} [season] [DEPRECATED] This field should not be considered reliable for the purposes of filtering matches by season.
         * @param {number} [endTime] The end time to use for filtering matchlist specified as epoch milliseconds. If beginTime is specified, but not endTime, then endTime defaults to the the current unix timestamp in milliseconds (the maximum time range limitation is not observed in this specific case). If endTime is specified, but not beginTime, then beginTime defaults to the start of the account\&#39;s match history returning a 400 due to the maximum time range limitation. If both are specified, then endTime should be greater than beginTime. The maximum time range allowed is one week, otherwise a 400 error code is returned.
         * @param {number} [beginTime] The begin time to use for filtering matchlist specified as epoch milliseconds. If beginTime is specified, but not endTime, then endTime defaults to the the current unix timestamp in milliseconds (the maximum time range limitation is not observed in this specific case). If endTime is specified, but not beginTime, then beginTime defaults to the start of the account\&#39;s match history returning a 400 due to the maximum time range limitation. If both are specified, then endTime should be greater than beginTime. The maximum time range allowed is one week, otherwise a 400 error code is returned.
         * @param {number} [endIndex] The end index to use for filtering matchlist. If beginIndex is specified, but not endIndex, then endIndex defaults to beginIndex+100. If endIndex is specified, but not beginIndex, then beginIndex defaults to 0. If both are specified, then endIndex must be greater than beginIndex. The maximum range allowed is 100, otherwise a 400 error code is returned.
         * @param {number} [beginIndex] The begin index to use for filtering matchlist.  If beginIndex is specified, but not endIndex, then endIndex defaults to beginIndex+100. If endIndex is specified, but not beginIndex, then beginIndex defaults to 0. If both are specified, then endIndex must be greater than beginIndex. The maximum range allowed is 100, otherwise a 400 error code is returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        matchV4GetMatchlist(encryptedAccountId: string, champion?: Array<number>, queue?: Array<number>, season?: Array<number>, endTime?: number, beginTime?: number, endIndex?: number, beginIndex?: number, options?: any): AxiosPromise<MatchV4MatchlistDto> {
            return localVarFp.matchV4GetMatchlist(encryptedAccountId, champion, queue, season, endTime, beginTime, endIndex, beginIndex, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MatchV4Api - interface
 * @export
 * @interface MatchV4Api
 */
export interface MatchV4ApiInterface {
    /**
     * Get match by match ID.
     * @summary Get match by match ID.
     * @param {number} matchId The match ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MatchV4ApiInterface
     */
    matchV4GetMatch(matchId: number, options?: any): AxiosPromise<MatchV4MatchDto>;

    /**
     * Get match by match ID and tournament code.
     * @summary Get match by match ID and tournament code.
     * @param {string} tournamentCode The tournament code.
     * @param {number} matchId The match ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MatchV4ApiInterface
     */
    matchV4GetMatchByTournamentCode(tournamentCode: string, matchId: number, options?: any): AxiosPromise<MatchV4MatchDto>;

    /**
     * Get match IDs by tournament code.
     * @summary Get match IDs by tournament code.
     * @param {string} tournamentCode The tournament code.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MatchV4ApiInterface
     */
    matchV4GetMatchIdsByTournamentCode(tournamentCode: string, options?: any): AxiosPromise<Array<number>>;

    /**
     * Get match timeline by match ID. ## Implementation Notes Not all matches have timeline data.
     * @summary Get match timeline by match ID.
     * @param {number} matchId The match ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MatchV4ApiInterface
     */
    matchV4GetMatchTimeline(matchId: number, options?: any): AxiosPromise<MatchV4MatchTimelineDto>;

    /**
     * Get matchlist for games played on given account ID and platform ID and filtered using given filter parameters, if any. ## Implementation Notes A number of optional parameters are provided for filtering. It is up to the caller to ensure that the combination of filter parameters provided is valid for the requested account, otherwise, no matches may be returned.  If beginIndex is specified, but not endIndex, then endIndex defaults to beginIndex+100. If endIndex is specified, but not beginIndex, then beginIndex defaults to 0. If both are specified, then endIndex must be greater than beginIndex. The maximum range allowed is 100, otherwise a 400 error code is returned.  If beginTime is specified, but not endTime, then endTime defaults to the the current unix timestamp in milliseconds (the maximum time range limitation is not observed in this specific case). If endTime is specified, but not beginTime, then beginTime defaults to the start of the account\'s match history returning a 400 due to the maximum time range limitation. If both are specified, then endTime should be greater than beginTime. The maximum time range allowed is one week, otherwise a 400 error code is returned.
     * @summary Get matchlist for games played on given account ID and platform ID and filtered using given filter parameters, if any.
     * @param {string} encryptedAccountId The account ID.
     * @param {Array<number>} [champion] Set of champion IDs for filtering the matchlist.
     * @param {Array<number>} [queue] Set of queue IDs for filtering the matchlist.
     * @param {Array<number>} [season] [DEPRECATED] This field should not be considered reliable for the purposes of filtering matches by season.
     * @param {number} [endTime] The end time to use for filtering matchlist specified as epoch milliseconds. If beginTime is specified, but not endTime, then endTime defaults to the the current unix timestamp in milliseconds (the maximum time range limitation is not observed in this specific case). If endTime is specified, but not beginTime, then beginTime defaults to the start of the account\&#39;s match history returning a 400 due to the maximum time range limitation. If both are specified, then endTime should be greater than beginTime. The maximum time range allowed is one week, otherwise a 400 error code is returned.
     * @param {number} [beginTime] The begin time to use for filtering matchlist specified as epoch milliseconds. If beginTime is specified, but not endTime, then endTime defaults to the the current unix timestamp in milliseconds (the maximum time range limitation is not observed in this specific case). If endTime is specified, but not beginTime, then beginTime defaults to the start of the account\&#39;s match history returning a 400 due to the maximum time range limitation. If both are specified, then endTime should be greater than beginTime. The maximum time range allowed is one week, otherwise a 400 error code is returned.
     * @param {number} [endIndex] The end index to use for filtering matchlist. If beginIndex is specified, but not endIndex, then endIndex defaults to beginIndex+100. If endIndex is specified, but not beginIndex, then beginIndex defaults to 0. If both are specified, then endIndex must be greater than beginIndex. The maximum range allowed is 100, otherwise a 400 error code is returned.
     * @param {number} [beginIndex] The begin index to use for filtering matchlist.  If beginIndex is specified, but not endIndex, then endIndex defaults to beginIndex+100. If endIndex is specified, but not beginIndex, then beginIndex defaults to 0. If both are specified, then endIndex must be greater than beginIndex. The maximum range allowed is 100, otherwise a 400 error code is returned.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MatchV4ApiInterface
     */
    matchV4GetMatchlist(encryptedAccountId: string, champion?: Array<number>, queue?: Array<number>, season?: Array<number>, endTime?: number, beginTime?: number, endIndex?: number, beginIndex?: number, options?: any): AxiosPromise<MatchV4MatchlistDto>;

}

/**
 * MatchV4Api - object-oriented interface
 * @export
 * @class MatchV4Api
 * @extends {BaseAPI}
 */
export class MatchV4Api extends BaseAPI implements MatchV4ApiInterface {
    /**
     * Get match by match ID.
     * @summary Get match by match ID.
     * @param {number} matchId The match ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MatchV4Api
     */
    public matchV4GetMatch(matchId: number, options?: any) {
        return MatchV4ApiFp(this.configuration).matchV4GetMatch(matchId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get match by match ID and tournament code.
     * @summary Get match by match ID and tournament code.
     * @param {string} tournamentCode The tournament code.
     * @param {number} matchId The match ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MatchV4Api
     */
    public matchV4GetMatchByTournamentCode(tournamentCode: string, matchId: number, options?: any) {
        return MatchV4ApiFp(this.configuration).matchV4GetMatchByTournamentCode(tournamentCode, matchId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get match IDs by tournament code.
     * @summary Get match IDs by tournament code.
     * @param {string} tournamentCode The tournament code.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MatchV4Api
     */
    public matchV4GetMatchIdsByTournamentCode(tournamentCode: string, options?: any) {
        return MatchV4ApiFp(this.configuration).matchV4GetMatchIdsByTournamentCode(tournamentCode, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get match timeline by match ID. ## Implementation Notes Not all matches have timeline data.
     * @summary Get match timeline by match ID.
     * @param {number} matchId The match ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MatchV4Api
     */
    public matchV4GetMatchTimeline(matchId: number, options?: any) {
        return MatchV4ApiFp(this.configuration).matchV4GetMatchTimeline(matchId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get matchlist for games played on given account ID and platform ID and filtered using given filter parameters, if any. ## Implementation Notes A number of optional parameters are provided for filtering. It is up to the caller to ensure that the combination of filter parameters provided is valid for the requested account, otherwise, no matches may be returned.  If beginIndex is specified, but not endIndex, then endIndex defaults to beginIndex+100. If endIndex is specified, but not beginIndex, then beginIndex defaults to 0. If both are specified, then endIndex must be greater than beginIndex. The maximum range allowed is 100, otherwise a 400 error code is returned.  If beginTime is specified, but not endTime, then endTime defaults to the the current unix timestamp in milliseconds (the maximum time range limitation is not observed in this specific case). If endTime is specified, but not beginTime, then beginTime defaults to the start of the account\'s match history returning a 400 due to the maximum time range limitation. If both are specified, then endTime should be greater than beginTime. The maximum time range allowed is one week, otherwise a 400 error code is returned.
     * @summary Get matchlist for games played on given account ID and platform ID and filtered using given filter parameters, if any.
     * @param {string} encryptedAccountId The account ID.
     * @param {Array<number>} [champion] Set of champion IDs for filtering the matchlist.
     * @param {Array<number>} [queue] Set of queue IDs for filtering the matchlist.
     * @param {Array<number>} [season] [DEPRECATED] This field should not be considered reliable for the purposes of filtering matches by season.
     * @param {number} [endTime] The end time to use for filtering matchlist specified as epoch milliseconds. If beginTime is specified, but not endTime, then endTime defaults to the the current unix timestamp in milliseconds (the maximum time range limitation is not observed in this specific case). If endTime is specified, but not beginTime, then beginTime defaults to the start of the account\&#39;s match history returning a 400 due to the maximum time range limitation. If both are specified, then endTime should be greater than beginTime. The maximum time range allowed is one week, otherwise a 400 error code is returned.
     * @param {number} [beginTime] The begin time to use for filtering matchlist specified as epoch milliseconds. If beginTime is specified, but not endTime, then endTime defaults to the the current unix timestamp in milliseconds (the maximum time range limitation is not observed in this specific case). If endTime is specified, but not beginTime, then beginTime defaults to the start of the account\&#39;s match history returning a 400 due to the maximum time range limitation. If both are specified, then endTime should be greater than beginTime. The maximum time range allowed is one week, otherwise a 400 error code is returned.
     * @param {number} [endIndex] The end index to use for filtering matchlist. If beginIndex is specified, but not endIndex, then endIndex defaults to beginIndex+100. If endIndex is specified, but not beginIndex, then beginIndex defaults to 0. If both are specified, then endIndex must be greater than beginIndex. The maximum range allowed is 100, otherwise a 400 error code is returned.
     * @param {number} [beginIndex] The begin index to use for filtering matchlist.  If beginIndex is specified, but not endIndex, then endIndex defaults to beginIndex+100. If endIndex is specified, but not beginIndex, then beginIndex defaults to 0. If both are specified, then endIndex must be greater than beginIndex. The maximum range allowed is 100, otherwise a 400 error code is returned.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MatchV4Api
     */
    public matchV4GetMatchlist(encryptedAccountId: string, champion?: Array<number>, queue?: Array<number>, season?: Array<number>, endTime?: number, beginTime?: number, endIndex?: number, beginIndex?: number, options?: any) {
        return MatchV4ApiFp(this.configuration).matchV4GetMatchlist(encryptedAccountId, champion, queue, season, endTime, beginTime, endIndex, beginIndex, options).then((request) => request(this.axios, this.basePath));
    }
}
